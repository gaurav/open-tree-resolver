/*
 * Store module for keeping track of the phyloreferences loaded, and for loading
 * additional phyloreferences.
 */

import Vue from 'vue';
import { has, isEqual, uniqWith } from 'lodash';

function addPhyloref(state, phyloref) {
  // Check to make sure this phyloref hasn't already been added.
  if(state.loaded.find(phy => isEqual(phy, phyloref)) !== undefined) return;

  // No previous match? Then add it in!
  state.loaded.push(phyloref);
}

function extractPhyloreferencesFromJSONLD(state, jsonld) {
  // Extract phyloreferences from the provided JSONLD file and add them to
  // state.loaded. We use isEqual to prevent adding the same phyloreference
  // more than once, but we will add different phyloreferences with the
  // same '@id'.

  // JSON-LD files sometimes contain an array of elements. In this case,
  // we should try adding every one.
  if(Array.isArray(jsonld)) {
    jsonld.forEach(element => extractPhyloreferencesFromJSONLD(state, element));
  }

  // If this was generated by the Authoring Tool, then we can find phyloreferences
  // just by looking for jsonld.phylorefs.
  if(has(jsonld, 'phylorefs') && Array.isArray(jsonld.phylorefs)) {
    jsonld.phylorefs.forEach(phy => addPhyloref(state, phy));
  }

  // If it was created by phyx2ontology, the phyloreferences can be recognized
  // has having a subClassOf 'phyloref:Phyloreference'. Let's look for that.
  if(has(jsonld, 'subClassOf')) {
    if(Array.isArray(jsonld.subClassOf) && jsonld.subClassOf.includes('phyloref:Phyloreference'))
      addPhyloref(state, jsonld);
    if(jsonld.subClassOf === 'phyloref:Phyloreference')
      addPhyloref(state, jsonld);
  }
}

function getSpecifiersFromClassExpression(classExpr) {
  let results = [];

  // If classExpr is an array, then process each entry separately.
  if(Array.isArray(classExpr)) {
    return classExpr
      .map(expr => getSpecifiersFromClassExpression(expr))
      .reduce((acc, val) => acc.concat(val), []);
  }

  // If classExpr itself has an equivalentClass, then we should process that instead.
  if(has(classExpr, 'equivalentClass')) {
    return getSpecifiersFromClassExpression(classExpr.equivalentClass);
  }

  // If there are additional classes, then process those too.
  if(has(classExpr, 'hasAdditionalClass')) {
    results = results.concat(getSpecifiersFromClassExpression(classExpr.hasAdditionalClass));
  }

  if(getLabelForSpecifierExpr(classExpr) !== undefined) {
    results.push(classExpr);
  } else {
    if(has(classExpr, 'someValuesFrom')) {
      results = results.concat(getSpecifiersFromClassExpression(classExpr.someValuesFrom));
    }

    if(has(classExpr, 'intersectionOf')) {
      results = results.concat(getSpecifiersFromClassExpression(classExpr.intersectionOf));
    }
  }

  return results;
}

function getLabelForSpecifierExpr(expr) {
    // Recognize the three standard expression forms.
    // Form 1. obo:CDAO_0000149 some (excludes_TU some ...) and (includes_TU some ...)
    if (
      has(expr, 'onProperty') && expr.onProperty === 'obo:CDAO_0000149' &&
      has(expr, 'someValuesFrom') && (
        has(expr.someValuesFrom, 'intersectionOf') &&
        getLabelForSpecifierExpr(expr.someValuesFrom.intersectionOf[0]) !== undefined &&
        getLabelForSpecifierExpr(expr.someValuesFrom.intersectionOf[1]) !== undefined
      )
    ) {
      const comp1 = getLabelForSpecifierExpr(expr.someValuesFrom.intersectionOf[0]);
      const comp2 = getLabelForSpecifierExpr(expr.someValuesFrom.intersectionOf[1]);

      return `MRCA(${comp1.substr(25)}, ${comp2.substr(25)})`;
    }

    // Form 2. includes_TU some (Name and scientificName some X)
    else if (
        (has(expr, 'onProperty') && expr.onProperty === 'phyloref:includes_TU') &&
        (has(expr, 'someValuesFrom') && (
          (has(expr.someValuesFrom, 'onProperty') && expr.someValuesFrom.onProperty === 'http://rs.tdwg.org/ontology/voc/TaxonConcept#hasName') &&
          (has(expr.someValuesFrom, 'someValuesFrom') &&
            (has(expr.someValuesFrom.someValuesFrom, 'intersectionOf')) &&
            (has(expr.someValuesFrom.someValuesFrom.intersectionOf[1], 'onProperty') &&
              expr.someValuesFrom.someValuesFrom.intersectionOf[1].onProperty === 'dwc:scientificName')
          )
        )
      )
    ) {
        return `includes scientific name ${expr.someValuesFrom.someValuesFrom.intersectionOf[1].hasValue}`;
        // return JSON.stringify(expr);
    }
    // Form 3. excludes_TU some (Name and scientificName some X)
    else if (
        (has(expr, 'onProperty') && expr.onProperty === 'phyloref:excludes_TU') &&
        (has(expr, 'someValuesFrom') && (
            (has(expr.someValuesFrom, 'onProperty') && expr.someValuesFrom.onProperty === 'http://rs.tdwg.org/ontology/voc/TaxonConcept#hasName') &&
            (has(expr.someValuesFrom, 'someValuesFrom') &&
              (has(expr.someValuesFrom.someValuesFrom, 'intersectionOf')) &&
              (has(expr.someValuesFrom.someValuesFrom.intersectionOf[1], 'onProperty') &&
                expr.someValuesFrom.someValuesFrom.intersectionOf[1].onProperty === 'dwc:scientificName')
            )
        ))
    ) {
        return `excludes scientific name ${expr.someValuesFrom.someValuesFrom.intersectionOf[1].hasValue}`;
        // return JSON.stringify(expr);
    } else {
        // Could not match!
        return undefined;
    }
}

export default {
  state: {
    loaded: [], // Phyloref objects currently loaded.
  },
  getters: {
    getLabelForSpecifier: (state, getters) => (expr) => {
      // Given a specifier expression, return a description of what it's doing.
      return getLabelForSpecifierExpr(expr);
    },
    getSpecifiersForPhyloref: (state, getters) => (phyloref) => {
      // phyloref: Phyloreference to retrieve specifiers from.
      //
      // All phyloref objects should have internal and external specifier
      // information. But first, let's see if we can extract it directly from
      // the equivalentClass statement.

      return uniqWith(
        getSpecifiersFromClassExpression(phyloref || []),
        isEqual
      );

    }
  },
  mutations: {
    extractPhyloreferencesFromJSONLD
  }
};
